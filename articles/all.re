= はじめに

mugeneは、筆者が開発しているMMLコンパイラです。MMLとは（ここでは）music macro language@<fn>{mml}であり、音楽データをテキストで記述するための言語です。MMLという単語は「プログラミング言語」のように汎用的なもので、その文法は単一のものではありません。MMLコンパイラmugeneは、mugene独自の文法をもっており、その出力はMIDI（musical instrument digital interface）の音源で演奏することを前提としたSMF（standard midi format）です。

//footnote[mml][MMLという略語は、他にもmusic markup language、medical markup languageなど、いくつかの語句のacronymとして使われています。]

MMLがどんなものか、ごく簡単に一例だけ紹介しますが、次の1文は「テンポ100でピアノの音で『かえるのうた』を演奏する」ものです。

//emlist{
1  t100 @0 l4 cdefedc2  efgagfe2  crcrcrcr  l8ccddeefferdrc2
//}

意味が分かるかもしれないように説明しておくと、最初の@<tt>{1}は「トラック番号」、@<tt>{cdefgab}でドレミファソラシ、@<tt>{r}は休符、音符や休符の後は長さ（無指定時は @<tt>{l} で指定した4分音符）です。今わかる必要はありません。

MMLは20世紀にPC上で作曲する際に使われたツールです。本書執筆時である2018年現在、PCで作曲する人は、大抵はDAW（digital audio workstation）を使います。MML使いは希少種です。

MMLツールには、プログラミング言語環境と同じように、さまざまなレベルのものが存在します。簡単なメロディを1行のテキストで書くようなことを主目的にしているものもあれば、ゲームのBGMなどMIDI楽曲として聴くに耐えるものを作るために存在しているものもあります。mugeneはどちらかと言えば後者であり、ややこしい命令を備えています。


== 本書の目的と特性

本書は、MMLコンパイラmugeneを使って、MMLからMIDI楽曲を制作するために必要な知識を、筆者なりの方法で解説して、MMLを使って作曲する際のスタートアップガイドとなることを目的としています。その一方で、MMLは一般解の少ない特殊な文化であり、mugeneにはさまざまな技術上の選択を行っている側面もあります。自分の選択が唯一解ではないことを説明（あるいは弁解）するために、MMLの歴史的背景や前提知識について説明して（一見）無駄にページを割いていることもあります。そういう部分に興味が無ければ読み飛ばすと良いでしょう。





= MMLと音楽演奏データ

本章では、mugeneが前提とするMIDIについて、MIDI以前の技術も振り返りつつ、音楽の演奏データの構造がどのようになっているかを説明します。mugeneそのものについては以降の章で説明していきます。

== 歴史的な背景

MMLという言語は特殊なジャンルですが、その特殊なジャンルの中には数多のMML文法が存在しています@<fn>{mml_variants}。MMLが隆盛した20世紀の日本には、PC-88/98、X68000、FM-TOWNS、MSXといった、現在のPCとは異なるPCが多数存在しており、動作しているOSもWindowsではない、MS-DOSなどシングルタスクで単一のアプリケーションが全画面を専有するものが主流でした。この時代の音源は（有る場合は）主にPCに付属するFM音源であり、ソフトウェアでPCM音声を合成して楽曲を演奏する処理速度はPCにはありませんでした（MicrosoftがWindows 98からMicrosoft GS Wavetable Synthを搭載しています@<fn>{fpd}）。

//footnote[mml_variants][N88-BASIC、MXDRV、Z-MUSIC、MUAP98、PMD、FMP、mml2mid、テキスト音楽サクラ、FIMML、TSS、SiON…]
//footnote[fpd][筆者の知識の範囲では、PC-98上で動作するFPDが、MIDIファイルからの変換をサポートした最初の多重音声PCM音源ドライバです。 http://www.vector.co.jp/soft/dos/art/se012450.html]

当時の日本のFM音源は、たいがいYamahaのYM-xxxxという品番のものでしたが@<fn>{soundblaster}、その種類もひとつではなかったので、環境によってさまざまな「音源ドライバ」が存在していました。音源ドライバは、演奏データを受け取って、音源の仕様に基づいて再生したり停止したりします。音源の性能（同時発音数やそもそもFMオシレーターの数など）は基板によってことなり、また当時のプログラミング環境ではタイマーの実装も環境や音源に依存しており@<fn>{timer_a_b}、高度なタイマーを処理するパワーも無かったので、音源ドライバはそれぞれが独自の発展を遂げており、データフォーマットはおろかデータの内容も多様でした。MMLは最初からバベルの塔が崩壊した世界で誕生したわけです。

//footnote[soundblaster][海外ではSoundBlasterが主流であったといえそうです。]
//footnote[timer_a_b][たとえばYamahaのYM-2203にはTimer-AやTimer-BというレジスタにハードウェアI/O命令でテンポを設定する必要があり、これはマイクロ秒のような単位で設定するものではありませんでした。]

このような状況の中で@<fn>{eras}、音源や音楽ソフト間の共通規格を定めたのがMIDIであり、楽器の定義はGM（General MIDI）音源、ファイルフォーマットにはSMF（standard MIDI format）など、いくつかの仕様が作成されました。このMIDIをターゲットとするMMLコンパイラもいくつか開発されましたが@<fn>{mml-midi}、MIDI音源やSMFフォーマットがFM音源やそのドライバの独自フォーマットに取って代わるまでは長い時間がかかり、その間にMMLによる楽曲制作はマイノリティとなっていきました。

//footnote[eras][ここで説明している時代背景は主に80年代後半〜90年代前半ですが、MIDI規格は1983年には成立しているものです。MIDIが解決しようとする課題そのものは、ここで説明している時代以前から存在していました。]
//footnote[mml-midi][筆者の知る限りでは、mml2midなどが最初期のもので、現在もっとも有名なのは テキスト音楽サクラ でしょうか。筆者はMUCというMMLコンパイラを使っていました。]

MIDIファイルをMMLコンパイラで作成するのは、主に過去にMMLによる楽曲制作を行っていて、それが最も手に馴染むという人や、制作と演奏でツールを使い分けたいといった嗜好の人が大半でしょう。


== MIDIと音楽データの構造

前述の通り、音楽演奏データはドライバによって異なるものです。最もプリミティブな例を挙げると、任天堂のファミリーコンピューターで使用されているFc音源やそのエミュレーション環境で演奏するデータを作成するツールとしてMCKというMMLコンパイラがありますが、MCKが生成するのはファミリーコンピューターのCPUである6502上で動作する「プログラム」です。コンピューターに接続された音源は、CPUにとっては外部デバイスであり、外部デバイスへのI/O命令を通じて制御されるので、演奏データがプログラムそのものである、というのはある意味もっとも柔軟な（プログラマー向けにいえば「低レベルな」）データフォーマットであるといえます。

こういうフォーマットで生成されたデータは、コンピューターの命令セットやデバイスが変わってしまったときに、全く使えないものになってしまいます。そこまで極端ではなくても、FM音源ではドライバが乱立し命令セットもファイルフォーマットも環境依存であったため、ある程度統一して複数の環境で利用できるよう、標準音源の提案と楽器とやり取りする命令、演奏データのフォーマットなどを規格として定めたのが、先にも言及したMIDIです。MIDIによって、音楽データの構造がある程度シンプルになりました。

音楽演奏データにはどのような情報があるでしょうか。ここではデジタル化以前の典型的なフォーマットである「楽譜」を引き合いに出して、いくつかの重要な要素を取り出していきます。

(1) @<b>{パート}: ひとつの完成した楽曲は、通常は複数のパートで構成されます（ソリスト用の曲もあります）。これはMIDIにおいては「チャンネル」や「トラック」という概念が割り当てられます。楽譜におけるパートには通常はひとつの楽器が割り当てられますが、MIDIのチャンネルは途中で楽器を切り替えることができます。

(2) @<b>{楽器}: ピアノ、ギター、ドラム、ヴァイオリン、人間の声など、さまざまな楽器があります。MIDI規格では、128種類の音源が規定されています。楽器のことをプログラムと呼び（一般的な意味での実行プログラムとは意味が違います）、チャンネルで使用する楽器を指定する命令を@<b>{プログラム・チェンジ}といいます。

(3) @<b>{音符}: どんな楽譜にも必ずあるのが、音階と音の長さを示す音符です。音符は、MIDIではノート命令、具体的には@<b>{ノートオン}（音を鳴らす）と@<b>{ノートオフ}（音を止める）という命令で表します。音階は0〜127で表し、大きい数値であれば高い音となります。音の「長さ」（以降は「音長」と書きます）は、命令と次の命令の間の待機時間として表します（全てのMIDI命令のメッセージには「次の命令までの待機時間」が付きます）。ちなみに「休符」に対応する「命令」はありません。ノートオフから次のノートオンまでの待機時間が、休符の分だけ加算されるだけです。

(4) @<b>{テンポ}: 楽譜ではあいまいにlargo, andante, allegroなどと指定されるのをよく見たと思いますが、コンピューターは具体的な数値でないと理解できません。MIDIではBPM（beat per minutes、1分あたりの4分音符の数）と4分音符ひとつにかかるマイクロ秒単位の時間の組み合わせでテンポを表現します。

(5) その他の装飾記号: フォルテやピアニッシモといった強弱、スラーによるなめらかな音符の接続など、楽譜にはさまざまな表現があります。MIDI規格では、ノートの強弱にはベロシティ、音程のなめらかな移動にはピッチベンドなど、いくつかのパラメーターが用意されています。ベロシティとピッチベンド以外は、だいたいエフェクトであり、これらは@<b>{コントロール・チェンジ}と呼ばれる命令の引数で、さらに細かく種類を指定して制御します。

=== チャンネルとトラック

1つのチャンネルには1つの時点では1つの「楽器」を演奏することしかできません。MIDIでは16チャンネルが利用可能となっています。16チャンネル以上で楽器を同時に使用したい場合は、SMF（標準MIDIフォーマット）のデータ構造では扱わず、複数のMIDIデバイスを同時に使うことで対応します（とはいっても、そこまでの規模の楽曲を、無理に標準MIDIの範囲で制作する必要はないでしょう）。

また、16チャンネルのうち、10番目のチャンネルはドラムパート用に予約されており、このチャンネルのノート命令では、ノートごとに異なるリズム楽器の音が割り当てられています。例えば、ドの音を鳴らしたらキックドラムが出たとしても、レの音はそのキックドラムの音階が違うものが鳴るわけではなく、スネアドラムの音が出ることになります。

なお、MIDI規格では、1つのチャネルで複数の音階のノート（音）を発声できることになっています。FM音源では、1つのチャネルでは1音しか発声できず@<fn>{fm_poly}、和音を鳴らそうと思ったら、それだけで複数チャネルを占有することになります。FM音源はたいがい3チャンネルとか6チャンネルとか8チャンネルくらいしかないので、本格的なポップスなどの楽曲を制作するのは無理があるでしょう（FM音源で本当にそこまでやりたい場合は、いったんPCMで録音してからミックスします）。

//footnote[fm_poly][これは論理的な必然ではありませんが、通常はFM音源の「チャンネル」に割り当てられる音色はオシレーターを組み合わせて表現され、これを分解して別々の音階を同時に鳴らすことは想定されません。FM音源によっては、一部チャネルのオシレーターを分解して独立した音を出せたものもありますが、特殊な例です。]

=== 標準楽器

MIDIでは、その仕様の一部であるGeneral MIDI楽器として（GM音源ともいいます）、128種類の楽器とドラム用の楽器がいくつか規定されています。楽器というのはクリエイティブなものであり、アーティストが独自の楽器を作ることもよくありますが、GMはそういった表現には向いていません@<fn>{midi_ctrl}。また同じ「ギター」でも、メーカーや演奏する人によって出る音は大きく変わるのが一般的でしょう。GMは「標準規格」であり、標準規格で表現できる音楽データは最大公約数的なものでしかありません。細かい表現を追求するなら、標準規格を外れたところで表現するのが良いでしょうし、本格的なデジタル楽曲制作ではそれが一般的です。

RolandはGMを拡張した音源規格としてGSを、Yamahaは同様にXGを、それぞれ定めていますが、ほぼ同様の議論が当てはまります。

//footnote[midi_ctrl][楽器の制御をMIDIメッセージで行うということは、今でも一般的に行われています。]

さいわい、MIDI仕様の策定者も、ひとつのGM音色には複数のバリエーションがあるべきであることを理解していたので、MIDIで音色を指定する際には、プログラムとは別に<b>{バンク}とよばれるバリエーションの指定も可能になっています。MIDI音源、とくにハードウェア音源では、音色はプログラム・チェンジとバンク・セレクトを組み合わせた128音以上の選択肢から選ぶのが一般的です。筆者が大枚をはたいて購入したRoland Integra-7というハードウェアMIDI音源には6000音色分のデータが搭載されています@<fn>{num-tones}。

//footnote[num-tones][実際には、ドラムパート用の音色はリズム音色セット1つにつき20音以上含まれていることになるので、それを考慮した上で数字を見るべきです。]

また、MIDIの範囲を越える楽器でも、VSTi（Virtual Studio Technology - instrument）などの技術に基づくソフトウェアシンセであれば、DAWなどを使えば、音色以外の演奏情報はMIDIやそれに準ずる命令集合を用いてMIDIのような感覚で音楽制作できるでしょう。


== 音楽制作・再生環境

本書で解説するmugeneはMMLコンパイラです。MMLコンパイラは単なるコンソールツールで完結するので、MS-DOSなどの環境の頃からフリーソフトなどで比較的お手軽に開発されてきたものです（ただし、通常は音源ドライバを伴うもので、その開発がメインであったともいえるでしょう）。この意味では、mugeneは古典的なツールです。もっとも、実装言語がC#であり実行環境がMonoあるいは.NET Frameworkであるため、古いPC環境では動作しないでしょう。

使い方も簡単で、コンパイラツールの後にMMLファイル名を指定して実行すると演奏データファイルが出力されるだけ、というのが一般的です。（例: @<img>{mugene-console-use}）

//image[mugene-console-use][mugeneをコンソールで実行]

MIDIが音源として使われるようになった時代にはDAWによる制作が一般的になってきて、MIDIをサポートするMMLコンパイラというのはやや時代のギャップがありますが、プログラマブルに音楽制作を行いたい人にとっては、MMLコンパイラはなお有力な選択肢であったといえるでしょう。ただ、さすがに2018年現在もMMLで楽曲を制作する人は多くありません。

mugeneはSMFを生成するコンパイラですが、FM音源とMIDI音源以外の世界にも音楽データのフォーマットは存在しています。有名なところではMODというPCMデータを用いる音楽データがあります。

mugeneは今のところSMFをターゲットにしており、これ以外のチャンネルを対象にすることは今のところ考えていません。全く新しい音源やドライバをターゲットにする場合は、新しいコンパイラを書いたほうが良いだろうと考えています。形式上SMFではないがSMF互換の命令セットやデータを出力すれば良いというものに関しては、この限りではありません。たとえば、Vocaloid2でサポートしていたフォーマット.vsqは、その実態は単なるSMFに則ってメタデータなどを拡張したものであって、mugeneを少し拡張するだけで生成できるものでした。そのため、mugeneではVocaloid2をサポートしています@<fn>{vocaloid4}。

//footnote[vocaloid4][Vocaloidは既にバージョン4であり、.vsqサポートは古いものです。]


== 典型的なMMLの特徴

MMLは、PC上のCPU、メモリ、ディスクなどのリソースが限られていた時代に、その強い制約を受けながら発展してきた言語生態系です。21世紀になるとXMLのような冗長な記述が盛んになりましたが@<fn>{music_xml}、MMLは1行のテキストにノートなどの各種命令を記述していくスタイルです。もちろん、数小節書いてテキストエディタの横幅いっぱいになってきたら、行を改めて書くことになります（可能です）。（例: @<img>{mml_sshot}）

//image[mml_sshot][mugene MMLの編集画面(vim)]

また、一般的なMMLは楽曲を制作するために用いられる言語であり、ノートひとつにつき1行、のような記述には馴染みません。GUIベースで音楽制作する環境のいち類型としてTrackerというジャンルのツールがありますが、Trackerは1つのノート命令で1行が消費されます（複数トラックが横に並ぶ構成でもあり、また演奏中は自動スクロールで追尾するのが一般的なので、MMLとは根本的にスタイルが違います）。

//footnote[music_xml][MusicXMLやMusic Markup Languageといった言語はXMLを採用しています。これで作曲したいか、という観点で見ておくのも良いでしょう…]

音楽を構成するために記述する命令が簡潔に書けるのは、命令がほとんど1文字の識別子で提供されているからであり、すなわち一見すると何が記述されているのか把握しづらい、という問題があります。一方で、MMLに慣れていると、命令語の短さは、テキストエディタのビューで大まかに楽曲の流れがある程度把握できるという利点になります。

MML文法にも、筆者が記憶している中には、Cに近いinclude構文をサポートしたり、パートごとに@<tt>{{}〜@<tt>{\}}で囲ったりするものもありましたが、これくらいの冗長さであれば現代的には十分に受け容れられるものでしょう。

mugeneのように、楽曲を記述できる程度の機能をサポートするMML文法では、「マクロ」を定義して、あるパターンに沿ったMMLを簡潔に記述できるようになっているのが一般的です（ごく簡単なMMLコンパイラには存在しない機能です）。プログラミング言語における関数のようなものですが、そこまで高度なものではないのが一般的です。引数もサポートしたりしなかったりです。

MML文法によっては、大文字・小文字を区別しないものもあります。もっとも、MMLにおける命令は通常はかなり短いものであり、ある程度の規模の音楽制作に耐えることを想定しているツールでは、これらを区別する文法のほうが一般的でしょう。文法によっては、「大文字識別子のマクロは2文字以上」のようなルールを導入しているものもあったりします。

=== 典型的なMML命令

典型的なMML命令には、次のようなものがあります。（@<table>{typical_mml_operators}）

//table[typical_mml_operators][典型的なMML表]{
命令	意味	命令	意味
----------------------------------
cdefgab	ノート	r	休符
l	デフォルト音長指定	q	発音時間（ゲートタイム）指定
o	オクターブ指定	< >	オクターブ相対指定
v	音量指定	( )	音量相対指定
@	音色指定	[ 〜 ]n	繰り返し（n回）
t	テンポ指定	B	ピッチベンド指定
//}

これらはあくまで例であって、実際の文法次第です。

オクターブ相対指定で@<tt>{\<}と@<tt>{\>}のどちらが上げるか・下げるかはMML方言によって大きく二分するところです。mugeneのデフォルトは@<tt>{<}が1オクターブ下げるほうです。





= mugeneチュートリアル

== mugeneコンパイラの使い方

mugene MMLコンパイラはC#で書かれた.NETのコンソール・ツール（mugene.exe）です。筆者は主にUbuntu Linux上で開発しているので、monoを使って実行しています。Windowsではそのままmugene.exeを実行すればよいでしょう。

mugeneは（2018年4月時点では）githubとnugetでのみ公開しています。いずれ整備しますが、現時点では次のように必要なファイルを全て集めて実行するのが楽でしょう。

//emlist{
$ nuget install mugene
(コンソール出力略)
$ cp managed-midi.1.1.0/lib/net45/* .
$ cp -R mugene.1.1.4/lib/net45/* .
$ echo "1  t100 @0 l4 cdefedc2  efgagfe2  crcrcrcr  l8ccddeefferdrc2" > frog.mugene
$ mono mugene.exe frog.mugene
Written SMF file ... frog.mid
$ ls frog*
frog.mid  frog.mml
//}

このMMLは冒頭に出した かえるのうた です。コンパイル結果として@<tt>{frog.mid}が生成されていることがわかります。内容を見るとこうなっています。（全部載せるまでもないのですが、これくらいのサイズであることを示す意図で載せています。）

//emlist{
$ hexdump frog.mid
0000000 544d 6468 0000 0600 0100 0100 3000 544d
0000010 6b72 0000 fd00 ff00 0351 2709 00c0 00b0
0000020 0000 0020 c000 0000 3090 3064 3080 0000
0000030 3290 3064 3280 0000 3490 3064 3480 0000
0000040 3590 3064 3580 0000 3490 3064 3480 0000
0000050 3290 3064 3280 0000 3090 6064 3080 0000
0000060 3290 3064 3280 0000 3490 3064 3480 0000
0000070 3590 3064 3580 0000 3790 3064 3780 0000
0000080 3590 3064 3580 0000 3490 3064 3480 0000
0000090 3290 6064 3280 0000 3090 3064 3080 3000
00000a0 3090 3064 3080 3000 3090 3064 3080 3000
00000b0 3090 3064 3080 3000 3090 1864 3080 0000
00000c0 3090 1864 3080 0000 3290 1864 3280 0000
00000d0 3290 1864 3280 0000 3490 1864 3480 0000
00000e0 3490 1864 3480 0000 3590 1864 3580 0000
00000f0 3590 1864 3580 0000 3490 1864 3480 1800
0000100 3290 1864 3280 1800 3090 6064 3080 0000
0000110 2fff 0000
//}

冒頭の@<tt>{MThd}やその後ろにある@<tt>{MTrk}といったチャンクを含み、0x1Fバイト目からの@<tt>{00 90 32 64}はノートオン、その直後の@<tt>{30 80 32 00}は30tick後にノートオフ…といった、標準的なMIDIファイルのフォーマットになっています。

生成された@<tt>{.mid}ファイルは、（おそらくどのOS環境でも）選択して関連付けられたアクションを実行すると、相応するメディアプレイヤーが開いて再生が始まるでしょう。筆者が作りかけ@<fn>{xmdsp_ongoing}のヴィジュアルMIDIプレイヤーxmdsp@<fn>{xmdsp-repo}も雑に宣伝しておきます。

//image[xmdsp][Xmdsp]
//footnote[xmdsp_ongoing][筆者がMMDSPみたいなプレイヤーを作ってみたかっただけなのですが、対象がMIDIだとスペアナなどを表示してもほぼ意味がなく、空白を埋めるアイディアも特に無いので、中途半端な状態のままになっています。]
//footnote[xmdsp-repo][https://github.com/atsushieno/xmdsp]


== パート構成をトラックにマッピングする

ここまでのサンプルでは かえるのうた しか扱っていませんでした。本書は かえるのうた をMMLで打ち込めるようになるためのものではありません。まともな楽曲を制作できるようになるためには、あとどのような知識が必要なのでしょうか?　この疑問に対してどう答えるのが正しいのか、あるいは妥当なのかは難しいところですが、まず意識しておくべきことは、われわれが扱っているのはデジタル音楽であるということと、MIDIはさまざまな音源の最大公約数であり、その表現力には制約が（それも、かなり大きな制約が）あるということです。期待値を下げて臨みましょう。

MMLでMIDI楽曲を制作するには、次に挙げる作業が必要になるでしょう。

 * 楽曲のパートをトラックに割り当てる
 * 各トラックごとに音符を載せていく
 * タイトルや作曲者情報を記述する

=== パート構成をトラックにマッピングする

多くの音楽は、複数のパートから構成される、と前章で説明しました。これをもう少し掘り下げてみましょう。たとえば、ロックのパート構成は、典型的には次のようなものが考えられるでしょう（これらが全て揃っていないこともよくあります）。

 * ヴォーカル
 * ギター
 * ベース
 * ドラム
 * キーボード

GM音源でヴォーカルを打ち込むのは無理で、この部分は（もし本当に必要なら）Vocaloidのようなソフトウェアを使って解決することになります。その他のパートはGM音源で実現可能です。ギターはプログラムNo.24〜31、ベースはNo.32〜39、ドラムは10チャンネルのリズムトラック、キーボードはさまざまな音色で実現可能です。No.0@<fn>{program_index}のピアノやNo.16のオルガン、No.48のストリングス、No.61のブラスセクションなどは典型的な音色で使いやすいでしょう。これらのそれぞれにトラックを割り当てます。ギターとキーボードはポリフォニック（複数のノートを同時に発声するモード）であり、ベースはモノフォニック（単音）です。（ドラムの打ち込みは特殊なのでここでは例示しません。）

//footnote[program_index][この説明で分かる読者もいるかもしれませんが、本書ではプログラム・チェンジの番号を1〜128ではなく、0〜127で記述します。これはmugeneにおける記法と合致するものです。]

この構成はモダンな音楽の大半で通用するでしょう。オーケストラ楽曲ではもっと多くのパートが必要になります。テクノではもっとクリエイティブな音色を使うことが多いでしょう。

多くの場合は、1パートにつき、1トラックが存在していれば大丈夫ですが、ドラムに関しては、キックドラム、スネアドラム、ハイハット、クラッシュシンバルなど、パートを複数使用したほうが効率的な打ち込みが可能でしょう。また、トラックをひとつ使用して、どのチャンネルにも属さない命令（たとえばテンポ変更など）をまとめておくと、後から読みやすいでしょう@<fn>{tempo_change_bugs}。

//footnote[tempo_change_bugs][テンポ変更や拍子変更を通常トラックに分散して記述していると、後で思い通りの音楽演奏になっていない時に、原因箇所の特定に時間がかかります。]

=== トラックに演奏命令を記述する

トラックが決まったら、それぞれに必要なノート命令などを、他の命令（ボリューム、パン、ピッチベンド、リバーブなど）を使って表現を調整しながら打ち込んでいくことになります。mugene MMLのトラックの内容は、行頭にトラック番号を書いて、1文字空白（spaceかtab）を入れて、あとはMML命令を書くだけです。ここからは、さまざまな命令を使いながら学んでいく必要があるでしょう。

打ち込みの進め方は制作者次第です。メロディから書き始めるのもよし、キーボードでコードを作り始めるもよし@<fn>{chord_driven}、リズムパターンから入っても良いでしょう。特に最初のうちは「出来ること」を増やすのも重要です。また全パートを少しずつ進めるのか、1パートだけ先行するのか、といった部分も人それぞれです。

//footnote[chord_driven][楽曲のコード進行を決めるのは、たいがいはキーボードではなくベースになるでしょうから、実際のコードはベースを打ち込み始めてから決まることになるでしょうが、頭に浮かんだ音楽を実装する意味ではどこから始めても良いでしょう。]

mugeneで制作していくのであれば、その命令を知っていく必要もあるでしょうが、読者にあまり深入りしてもらうほど息の長いツールにするつもりもないので、どちらかといえばそれぞれのMML命令がMIDIのどのような機能に対応するかを理解しながら読み解いてもらいたいと考えています。そうすれば、他のMMLツールやDAWなどを使った打ち込みにシフトしていっても役に立つ知識となることでしょう。

=== MIDIメッセージ

mugeneの命令は、最終的には何らかのかたちで出力されるMIDIメッセージに反映されることになります。MIDIメッセージには次の8種類があります。（@<table>{typical_midi_messages}）

//table[typical_midi_messages][MIDIメッセージの種類]{
コード	引数	意味	mugene MML
----------------------------------
80H	[キー]、[ベロシティ]	ノートオフ
90H	[キー]、[ベロシティ]	ノートオン	n, cdefgab
A0H	[キー]、[値]	PAf	PAF
B0H	[No.]、[値]	CC	CC
C0H	[No.]	プログラムチェンジ	@
D0H	[値]	CAf	CAF
E0H	[値2バイト]	ピッチベンドチェンジ	B
F0H	[可変長]	システムメッセージ
//}

コードは16進数です。0となっている部分は、実際のメッセージでは対象チャンネルが0〜Fで指定されます。この基本構造のため、標準MIDIのチャンネルは必ず16までとなります。

mugene MMLでは、トラックごとに対象チャンネルを@<tt>{CH}命令で指定する必要があります。チャンネルが指定されなければ、全てチャンネル No.0に出力されます@<fn>{sample_mml_ch}。トラックとチャンネルは違うものを指定できますし、実際複数トラックで操作するチャンネルは0〜15以外で割り当てたほうが無難でしょう。

//footnote[sample_mml_ch][サンプルで何度か登場している かえるのうた は、CH命令を使っていないので、全てチャンネルNo.0に出力されています。]

ノートオンとノートオフは既に何度か登場しています。ノート命令については、単純なMIDI命令へのマッピングではなく、「ドレミファソラシ」に対応する@<tt>{c d e f g a b}で記述するのが一般的です（これらはドイツ語由来の記法です）。シャープは@<tt>{+}、フラットは@<tt>{-}を付加します。音階名だけではキーを特定できないので、MML上では「現在のオクターブ」をトラックごとに記憶しておいて、@<tt>{c d e f g a b}のいずれかが登場するたびに、オクターブと音階名から引数となるキー（0〜127）を計算します。オクターブは@<tt>{o}命令で指定し、@<tt>{>}や@<tt>{<}で1つずつ上げ下げできます。

MIDIメッセージ上はノートオンとノートオフは別々ですが、MML上ではノート命令に音長を指定するだけです。SMFファイル上は、ノートオンが終わったら音長のぶんだけ待機してからノートオフ命令を送るかたちです。

音長は@<tt>{l}命令でデフォルト値を指定でき、デフォルト音長のノート命令では音長を省略できます。また、@<tt>{.}（ドット）を音長の後ろにつけると付点となります。また、@<tt>{+}を使ってc2+8のような表記も可能です。ちなみに全ての音長は（デフォルトで）192の約数として指定される必要があります。192分音符、96分音符、64分音符は表現できますが、例えば100分音符を指定すると仕上がりが予測不能な（ずれた）曲になります。また、@<tt>{#}を使って、c192と書く代わりにc#1と書くことも可能です。

音長にはひとつ特殊ルールがあって、音長に0が指定された場合は、その次のノート命令で指定される音長が適用されます。これは和音を演奏する時に便利で、たとえば@<tt>{c0e0g1}と記述すると、ド・ミ・ソの和音が全音符で展開されます@<fn>{gate_and_step}

//footnote[gate_and_step][ノートの長さと次の命令までの間隔は、ノート命令の引数で別々に指定できるのですが、これは高度なトピックなので以降の章で扱います。]

また、ノート命令には、ベロシティという音量指定を追加することもできます。MIDIメッセージ80H@<tt>{noteoff-velocity}と90Hではベロシティが必ず指定されますが、ノート命令に音量を指定しなかった場合は、デフォルトベロシティとして@<tt>{v}命令で指定してあった値が使われます。

//footnote[noteoff-velocity][ノートオフ＝消音になぜ音量パラメーターがあるのかというと、音が「どのように」消えるかを制御するパラメーターとして機能しているのです。0を指定すると唐突に消えて、大きな値を指定すると減衰音を残しつつ消える、といった制御が可能になります。これは音色依存、楽器依存の機能です。]

ここまでわかったところで、（しつこいですが）かえるのうた を見てみましょう。だいぶ読めるようになったのではないでしょうか。

//emlist{
1  t100 @0 l4 cdefedc2  efgagfe2  crcrcrcr  l8ccddeefferdrc2
//}

プログラムチェンジも既に説明した音色指定命令です。ピッチベンドは音程を半音よりもはるかに小さい単位で変化させる命令です。典型的なシンセサイザーでは、鍵盤の横にあるスライダーでこの命令が使われています。PAf（ポリフォニックキープレッシャー）とCAf（チャンネルプレッシャー）は鍵盤を押した時の深さをデジタル化したようなもの@<fn>{caf_dumper}で、楽器以外ではAppleのMagic MouseやiPhoneのタッチ操作における深さセンサーのようなものに近いです。PAfは鍵盤単位、CAfはチャンネル単位で、強弱のパラメーターを伴います。システムメッセージには、音源固有のメッセージをやり取りするためのSysEx（システムエクスクルーシブ）メッセージなどが含まれます。

//footnote[caf_dumper][CAfはピアノのダンパーペダルのようなものとも言えますが、これに相当するのはコントロールチェンジのダンパーペダルなので、話をややこしくしないために例としては用いません。]

=== コントロール・チェンジ

最後に残っているのはCC（コントロールチェンジ）ですが、ここにはさまざまなチャンネル別パラメータ制御命令があります。これは大量にあるので、いくつかよく使われるものだけ取り上げておきます。コードを覚える意味はほぼありません。mugeneの@<tt>{default-macro.mml}では、これらを簡単に指定できる命令を用意しています。（@<table>{control_changes}）

//table[control_changes][コントロールチェンジ一覧（抄）]{
コード	意味	mugene MML
----------------------------------
00H	バンク・セレクト		@
01H	モジュレーション	M
06H	DTE MSB	DTE, DTEM
07H	ボリューム	V
0AH	パン	P
0BH	エクスプレッション	E
26H	DTE LSB	DTE, DTEL
40H	ダンパーペダル（ホールド）	H
5BH	リバーブ（など）	RSD
5DH	コーラス（など）	CSD
5EH	ディレイ（など）	DSD
62H	NRPN LSB	NRPN, NRPNL
63H	NRPN MSB	NRPN, NRPNM
64H	RPN LSB	RPN, RPNL
65H	RPN MSB	RPN, RPNM
//}

モジュレーションはLFOなど時間に伴って周波数などを反復的に上下させるものです。パンは音の左右振り分けです。ダンパーペダルとはピアノのペダルの効果を表現するものです（音が延びたりします）。リバーブ、コーラス、ディレイは音の響き方、広がり方を変えるものです。

ボリュームとエクスプレッションはそれぞれ音量に影響するパラメーターです。これらの他にもノート命令のベロシティパラメーターやPAfがあるのですが、ボリュームは音量、エクスプレッションは発音後の強弱の変化を、それぞれチャンネル単位で指定するものです。ノートやPAfのパラメーターはキー単位で指定します（ここは学習したての時はそれほど気にしなくても良いでしょう）。

RPN、NRPN、DTEは、コントロールチェンジでもさらに足りない部分の制御を行います。RPNはregistered parameter number、NRPNはnon-RPN、すなわち標準化の有無です。RPNはチューニングのパラメーターなど、わずかな定義しかありません。NRPNはMIDIデバイス固有のパラメーターとなります。LSBは下位バイト、MSBは上位バイトで、計14ビット@<fn>{midi_msg_encoding}のデータを送信できます。使うときは、まずRPNやNRPNのメッセージ（LSB/MSBのペア）で対象パラメータ番号を指定して、次にDTE（LSB/MSBのペア）でその値を送信します。過去バージョンの話ですが、Vocaloid2では、このNRPNを活用して歌唱合成を制御していました。

//footnote[midi_msg_encoding][MIDIメッセージは1バイト = 8ビットのうち、sign flagなどで使う1ビットを除いた7ビットのみで数値を表すため、2バイトで14ビットとなります。]

これらはいずれも、知っておくと表現力が増すものなので、探究心をもっていろいろ実験してみると面白いでしょう。シンセサイザー固有の表現力もここに現れてきますし、GSやXGといったベンダー固有の共通規格のパラメータも活用するとよいでしょう。mugeneでは、@<tt>{nrpn-gs-xg.mml}というMMLがデフォルトで取り込まれており、この中では@<tt>{TVF_CUTOFF}（カットオフ）、@<tt>{TVF_RESO}（レゾナンス）などもサポートされています。

=== ドラムパートの打ち込み

ドラムパートは音色の扱いが特殊で、キーごとに全く異なる音が出る、というのは前述したとおりですが、mugeneではドラムパートも違和感なく打ち込めるように、ドラムパート用の命令を定義してあります@<fn>{drum-part-mml}。（@<table>{drum_mml}）

//footnote[drum-part-mml][ドラムパート用のMML命令は、@<tt>{default-macro.mml}ではなく@<tt>{drum-part.mml}に含まれています。]

//table[drum_mml][ドラムパート用命令]{
MML命令	意味
----------------------------------
b	bass drum (n36)
B	bass drum 2 (n35)
s	snare drum (n38)
S	snare drum 2 (n40)
TL	low tom (n43)
TM	mid tom (n47)
TH	high tom (n50)
c	closed hi-hat (n42)
o	open hi-hat (n46)
RC	ride cymbal (n51)
CR	crash cymbal (n49)
R	side stick (rimshot) (n37)
MT	muted triangle (n80)
OT	open triangle (n81)
//}

これらは全てノート命令@<tt>{n}を呼び出しているだけなので、ノート命令の他の引数は全て同じように指定できますし、ベロシティも@<tt>{v}命令の値が適用されます。実のところ、この程度の内容であれば、打ち込み時に自分でマクロ定義してしまったほうが良いと思います。ドラムパートで使える楽器は他にもたくさんあります。

典型的な4つ打ちのドラムフレーズの例を挙げると、こんな感じになります。

//emlist{
#define DRUMTRACKS 21,22
21  CH10 l4   cccc   ccoc  ccoc   l8 c4c4ococ
22  CH10 l4  bbsb  bbsb  bbsb  l8 b4b4sbs4
//}

mugene MMLでは、特定のトラックに限定したマクロを定義することが可能で、これらのリズム命令では、この機能を活用しています。@<tt>{o}命令を他のトラックで使用したら、オクターブ指定になります（ドラムパートでオクターブ指定は無用の長物なので、使い潰しているというわけです）。@<tt>{c}命令も他のパートではドの発音になります。どのトラックがドラムとして扱われるかは、@<tt>{#define DRUMTRACKS}の行で定義できます。

=== 楽曲メタ情報を記述する

最後に、SMFの楽曲にはメタデータとして、タイトルや作曲者の情報を埋め込むことができます。mugene MMLにも、それらを指定する方法があります。これらは@<tt>{#}から始まる1行で記述します（ディレクティブ行というもので、これについては以降の章で説明します）。

 * #meta title 楽曲タイトル
 * #meta copyright 著作権者
 * #meta text  その他のテキスト

ここまでの作業がこなせたら、まずはベタ打ちでもMIDIデータとして配布するのにはふさわしいMIDIデータになるでしょう。

=== ループを活用する

MMLで音楽を打ち込んでいると、同じフレーズや同じ命令列を何度も書くことがあります。コピーしてしまえば良いのですが、全部まとめて変更したくなると面倒です。mugeneでは、反復的な処理をまとめるやり方が２つあります。ループとマクロです。

まずループ処理です。@<tt>{[}〜@<tt>{]}@<i>{n}で囲まれた部分は繰り返しになります。@<i>{n}には繰り返したい数を指定します。

ループ命令は、実際にはもう少し複雑なことができます。ループの途中で@<tt>{:}@<i>{s}や@<tt>{/}@<i>{s}を指定すると、@<i>{s}回目のループの時のみ、その次の@<tt>{:}・@<tt>{/}あるいは@<tt>{]}までの範囲を処理します。これは主として楽譜の中で使われる反復記号を実現するためにあります。例を示しましょう。

//emlist{
10	[ b4b4 / s4b4 ]4  TH8TM8TL4
//}

これは、キックドラムとスネアドラムの4つ打ちですが、3小節同じフレーズで叩いた後、タムのフィルインに続いています。

次の例はもう少しややこしいです。

//emlist{
10	[ b4s4 :4 b8b8s4 : b4s4 ]8  TH8TM8TL4
//}

4小節目のときだけフレーズの後半が@<tt>{b8b8b4}になり、8小節目ではタムのフィルインに繋がります。

@<tt>{/}と@<tt>{:}で指定できる数値は、実はリストになっていて、「2回目と6回目だけこのフレーズ」みたいな指定も可能なのですが、使いこなすのは難しい（自分で書いたMMLを読み解くのが困難になる）ので、あまりオススメはしません。

=== マクロを活用する

単純な繰り返し以外の場面で、同じセットの命令を何度も指定したいことがあります。たとえばキーボードが単純な和音でコードを演奏しているとき、コードに対応する音符の集合を何度も記述するのは面倒です。こういうときは、マクロを活用します。

//emlist{
#macro CHORD_A c0e0g
#macro CHORD_B d0f0a
#macro CHORD_C c0e0g0b
1	@48 o5 l4 CHORD_A1  CHORD_B1  CHORD_B2 CHORD_B2  CHORD_C1
//}

注意すべきは、<b>マクロ名には数字を使えない</b>ということです。mugene MMLの命令はほぼ全てマクロで構成されています。命令には引数が伴います（マクロ定義では引数を定義することが可能です）。マクロ名に数字が使えてしまうと、命令の引数とマクロを区別できなくなってしまうのです。コードマクロだからといって、C_MAJOR、C_MAJOR_7などと命名しようとすると失敗します。

この辺りの事情は、一般的なプログラミング言語とは大きく異なります。一般的なプログラミング言語では@<tt>{(}〜@<tt>{)}などで関数名と引数を区別できますが、MMLでは誰も@<tt>{c(4)d(4)e(4)}などと書きたくないので、命令語の後は直ちに引数となります。

マクロ定義の内容は、命令語までは完全に展開できることが想定されていますが、引数までマクロ定義に含まれる必要はありません。これらのコード定義は@<tt>{g}、@<tt>{a}、@<tt>{b}といった命令の途中で終わっているので、@<tt>{CHORD_B2}のように続けて引数を指定することができます。これは2分音符の和音になっています。




= mugene MML文法解説

この章では、チュートリアルまでではカバーできなかった、MML文法のもう少し細かい部分について説明していきます。この章の内容を知らなくてもチュートリアルの範囲でMMLを書くことはできますが、知っておくと有用な情報やMML文法の論理的な側面などはこの章にあります。


== デフォルトマクロ: オーバーライド可能なMML命令定義

MMLはコンパイラの数だけ文法が存在するものです。mugeneのMML文法も独自のものです。mugeneはそれなりにしっかりした楽曲を制作できる程度には高度なもので、たとえばマクロ命令を定義して使用することが出来ます。

mugene MMLのひとつの大きな特徴は、自身の命令の大半をmugeneのマクロ定義構文によって定義していることです。コンパイラのコード自身もgithub上で公開しているので@<fn>{repo}、コードを独自にカスタマイズして使うことも可能ですが、そこまでやらなくても各種MMLコマンドを定義している@<tt>{default-macro.mml}というファイルをカスタマイズすることも可能です。

//footnote[repo][https://github.com/atsushieno/mugene]

その気になれば、かなり柔軟に命令を定義することも可能ですし、たとえばこれをカスタマイズして、実質的に大文字・小文字を区別しない命令セットを定義することも出来るでしょう。ただし、これは非常に難易度が高く、また簡単に他のマクロ定義とコンフリクトを起こすことにもなりうるので、基本的にはデフォルト定義のマクロの内容は書き換えない前提で説明を進めます。読者によっては、オクターブ相対指定や音量相対指定といった命令の「向き」が逆になっていることが耐え難い苦痛だという人もいるかもしれません。そういう人はこれらの命令を上書きすればよいのです。@<fn>{override_options}

//footnote[override_options][コンパイラによっては、これらの命令の向きをオプションで逆にしてくれるものなどがあったりしますが、他にも@<tt>{q}が@<tt>{Q}でないと受け付けない人、@<tt>{T}が@<tt>{t}でないと我慢できない人など、いろいろな人がいると思うので、mugeneでは命令定義そのものをカスタマイズ可能にする途を選びました。]

デフォルトマクロを書き換えて独自のデフォルトマクロを使いたい場合は、mugene.exeの引数にそのファイル名と@<tt>{--nodefault}という引数を追加します。そうすると、標準で取り込まれるデフォルトマクロは取り込まれなくなります。


== トラック行とディレクティブ行とコメント行

mugene MMLファイルは、行単位で解析されます。mugene MMLには、3種類の行があります。

 * @<b>{トラック行}: 音楽の演奏データを実際にトラックごとに記述していきます。行頭はオプションとなるブロック識別子アルファベットの後、トラック番号を表す数値になります。
 * @<b>{ディレクティブ行}: マクロ定義やメタデータ定義など、各種の非演奏データを記述していきます（これには、対象トラックが限定されるものと、そうでないものがあります）。行頭は@<tt>{#}になります。
 * コメント行: @<tt>{//}で始まる行で、以降改行まで無視されます。

mugene MMLにこれら以外の行は存在しません。@<tt>{#}、@<tt>{//}以外の文字で始まる行はトラック行となり、行頭をブロック識別子とトラック指定として解釈できない行はエラーとなります。ただし、空白文字で始まった場合、その行は前の行のトラック番号を引き継ぐトラック行となります。

マクロ定義が長くなったりして、次の行にも内容を続けたい場合には、行末にバックスラッシュを付加します。（@<img>{mml_wrap_backslash}）

//image[mml_wrap_backslash][バックスラッシュで次の行に繋げる例]


== 複数トラックの一括指定

トラック番号は数値ですが、実はここには単一の数値ではなく、複数のトラックをまとめて指定することが可能です。@<tt>{,}でその両脇の指定内容を結合し、<tt>{-}で範囲指定となります。例を挙げます。

 * @<tt>{1,2} : トラック1と2が対象です
 * @<tt>{3-5} : トラック3、4、5が対象です
 * @<tt>{1,3-5,7} : トラック1、3、4、5、7が対象です。

FM音源の世界では、同じパターン、同じ音色でも、周波数やタイミングを少しずらすことで厚みのある音を作り出すという表現技法がありましたが、MIDIにおいて同じ内容のデータを演奏する意味はほぼありません（厚みを出したかったらリバーブやディレイを適用すれば足ります）。しかし、作曲のパターンとして、キーを5度ずらして同じフレーズを演奏したり、あるいはユニゾンで別の楽器を演奏したりといったかたちで、同じMMLを複数トラックで演奏することはありえます。複数トラック指定はこういった場合に便利です。

== 引数付きマクロ

前章ではマクロ定義のごく基本的な部分を紹介しましたが、ここではマクロ定義の複雑な部分も含めて解説します。マクロ定義はディレクティブ行で、書式は次のとおりです。

//emlist{
#macro トラック番号 識別子 引数リスト { 内容 }
//}

トラック番号は通常は不要で、特定のトラックでのみ適用されるマクロを定義する場合には、前述のトラック指定の方法で指定します（範囲指定などが可能です）。

引数リストは引数定義を@<tt>{,}（カンマ）区切りで繋げたもので、引数定義は次のようになります。

//emlist{
識別子 : 型名 = デフォルト値
//}

デフォルト値が無い場合は、@<tt>{=}以下を省略します。

マクロ定義の内容は、トラック行のMMLと同様です。引数の内容を参照するには @<tt>{$} を識別子の前に付けます。次の例では、DTE命令を定義しています（実際に@<tt>{default-macro.mml}で使用されているものです）。

//emlist{
#macro DTEM val:number { CC #06,$val }
#macro DTEL val:number { CC #26,$val }
#macro DTE msb:number,lsb:number { DTEM$msb DTEL$lsb }
//}

=== 識別子

識別子は、マクロ名や引数の定義で用いられる文字列で、主としてMML中で命令を識別するためにある概念です。

一般的なプログラミング言語とは異なり、mugene MMLでは多くの文字が識別子名として許容されており（これは、MMLに慣れている人は自分の経験に合った文字を自分の好みの命令に割り当てられるようにするという意図で設計されているためです@<fn>{at_char}）、一方で（前述のとおり）一般的なプログラミング言語より厳しい制約もかかえています。

//footnote[at_char][たとえば@<tt>{@}が識別子として利用でき、実際プログラム・チェンジ命令で使われていることを思い出してください。]

識別子名の文法的制約は以下の通りです:

 * 常に禁止される文字: 0 1 2 3 4 5 6 7 8 9 " , { }
 * 先頭で使用できない文字: - + ^ ? #
 * 先頭でしか使用できない文字: / : ( )

=== 型: 数値、音長、文字列

MML命令のほとんどは、引数（パラメータ）を伴います。どんなパラメータを与えるかによって、（SMFに）出力される発音（命令）が変わってきます。

たとえば、今のトラックのオクターブを指定する命令 o は、オクターブの高さを引数にとります（o0 ～ o10）。プログラムチェンジやコントロール(CC)、アフタータッチなどは、MIDIメッセージと同等の引数をとります。複数の引数は、','（カンマ）で区切ります。

数値は通常は10進数として解釈されますが、# を付けることで16進数として解釈されます。

発音命令と休符命令の引数は少し特殊です。これは「数値」とは別に扱われる「音長」となります。たとえば r は休符命令ですが、r4 と書いた場合は4分休符になります。r1 と書いた場合は全休符になります。r8. と書いた場合は付点8分休符になります。

しかし、r4はコンパイラの内部では、4という数値としては処理されません。音長は、内部的には「ステップ数」という数値に変換されます。標準状態では、r4 は48ステップという数値になり、r1 は192ステップという数値になり、r8. は36ステップという数値になります。全休符を192として、音の長さを乗除算して出した数値になります。

音長は、数値の前に % を付けることで、このような数値として直接記述することもできます。たとえば r%48 は4分休符と同じです。

ちなみに、全休符に対応する 192 という数値は、@<tt>{#basecount}というディレクティブ命令で変更できます。

MML命令の中には、他にも「文字列」を引数に取るものがあります。文字列の値は "..." のかたちで、ダブルクォーテーションで囲んで記述します。一部の文字は、文字列の中で直接表現することができないので、「エスケープシーケンス」を使って表現します:

 *   \r : 改行(CR)
 *  \n : 復改(LF)
 *   / : スラッシュ
 *   " : ダブルクォーテーション
 *   \ : 円記号/バックスラッシュ

最後に、「型」について説明します。型はマクロを定義したり、MMLリファレンスを読んだりする時のために、理解しておく必要があります。

どのMML命令の引数にも「型」があります。命令を使うときは、それぞれの引数の型で期待される値を指定しなければなりません。mugene MMLには、以下の4種類の引数型があります:

 * number : 数値。整数となります。
 * length : 音長。上記の通りの意味で解釈されます。内部的には数値となります。末尾に付点を付けることで長さが1.5倍になり（多重付点も指定可能で、1.75倍、1.875倍…となります）、%を付けることでステップ数の直接指定となります。
 * string : 文字列となります。
 * buffer : これは __STORE という特殊な命令のために用意された、特殊な型で、通常はmugeneユーザーが使う必要はありません。

=== 変数

mugene MMLは音楽を打ち込むためのマクロ言語であって、一般的なプログラミング言語とは性格が大きく異なります。通常、ユーザーがプログラミングにおける「変数」のようなものを意識する必要はありません。しかし、いくつかの命令がどのように実装されているか気になる読者もいると思うので、説明します。変数はオクターブ指定、デフォルト音長指定、ベロシティ指定などでふんだんに使われています。

各トラックでは、変数を使用（格納したり参照したり）できます。使用するためには、事前に@<tt>{#variable}というディレクティブ行で定義したものになります。定義内容はマクロ引数と同様です。

//emlist{
#variable 識別子 : 型名 = デフォルト値
//}

変数の参照は、マクロ引数と同じ @<tt>{$変数名} となります。マクロ定義の中で活用できます。変数の代入は特殊で、@<tt>{__LET}という「プリミティブ命令」を使います@<fn>{primitives}。

//footnote[primitives][mugene MMLでは、ほぼすべてのMML命令を自分で定義できますが（それを実際に行っているのが@<tt>{default-macro.mml}です）、それらは最終的に「プリミティブ命令」の呼び出しになります。他にはMIDIのバイトデータになる@<tt>{__MIDI}や、マクロの呼び出しを動的に行う@<tt>{__APPLY}などがありますが、ここでは説明しません。]


== ノート命令の詳細とゲートタイム

音楽演奏データの打ち込みにあたって、意識しておくべきものに、音符の長さと実際に発音する音の長さの違いがあります。音楽記号にスタッカートというものがありますが、これは発音を短くすることを演奏者に指示するものです。スタッカート用のストリングス音色のように、バンク・セレクトで選択できる音源があれば、それで十分かもしれませんが、そうでなくても、発音する時間と次の発音まで待つ時間は別のものとして扱いたい音色やフレーズが、楽曲を制作しているとしばしば現れます。

このような時には@<b>{ゲートタイム}を活用します。ゲートタイムとは、音符に対する、実際の発音時間のことで、音長に対して割合指定したり、ステップ数を絶対値で短縮したりするものです。

mugene MMLでは、@<tt>{Q}@<i>{n}で割合指定（分母を@<tt>{GATE_DENOM}@<i>{n}で指定する分数指定です）、@<tt>{q}@<i>{n}でステップ数指定する、2つのゲートタイム指定方法を用意しています。これらはノート命令をMIDIメッセージのノートオンとノートオフに展開する際に適用されます。たとえば、@<tt>{q2}と指定されていたら、@<tt>{c4}は「ドを発音し、46カウント待ち、ドを消音し、2カウント待つ（そして次へ）」となります。

より突っ込んだ話を書くと、mugene MMLでは、ノート命令や休符命令を使うたびに、現在の演奏位置をあらわす@<tt>{__timeline_position}という変数の値を加算していきます。r命令には実はマイナスの値も指定でき、@<tt>{r-1}と書くと、全休符分巻き戻すことができます。和音を定義する時に音長が0のノート命令を記述しましたが、進むステップ数が0だということがこれで理解できると思います@<fn>{zero-length}。

//footnote[zero-length][音長0のノートの実際の発音長を調整するために、mugeneではさらに特別な命令@<tt>{__ON_MIDI_NOTE_OFF}を必要としましたが、これはさらなる実装の詳細なので、ここでは言及しません。]

== ピッチベンドとbend cent mode

MIDIメッセージE0Hはピッチベンドで使用されます。この値は14ビットの整数で、最大値は8191、最小値は-8192となります。この最大値と最小値が元の音からどれくらい離れているかは、ピッチベンド・センシティビティというRPNで表現されます。@<tt>{default-macro.mml}では@<tt>{PITCH_BEND_SENSITIVITY}というショートカット命令があります。この値が最大24で1オクターブです。

また、ユーザーが実際に-8192〜8191の範囲で数値を指定するのは困難なので、mugeneではB命令に即値モードとパーセンテージ指定モードの2つを用意しています。@<tt>{BEND_CENT_MODE}@<i>{n}命令を使うと、8192をこの値で割った数値に100をかけた値が、MIDIメッセージE0Hの引数として適用されます。この値とピッチベンド・センシティビティが同一であれば、100で半音階1つに相当します。これなら分かりやすいでしょう。@<fn>{muc-pitchbend}

//footnote[muc-pitchbend][この機能は筆者が過去によく使っていたMUC MML compilerというツールの機能を実現したものです。MUCには他にも筆者が影響を受けた機能がいくつかあります。]

=== spectra

MIDIで打ち込んでいると、ピッチベンドやエクスプレッションのようなパラメータを、ごく短い間隔で段階的に変更したくなることがあります。mugene MMLには、これを実現する機能<b>spectra</b>があります。

spectraは（スペクトラムから採っているのですが）、連続的に変化する数値を引数にとる連続的な命令を生成するためのものです。手作業で @<tt>{B0 r48 B-8 r48 B-8 r48 B-8 r48 ...} のように指定する代わりに、@<tt>{B_0, -200, 0, 2} のように「開始値、終了値、開始待機時間、変化期間」を指定するだけで滑らかに値が変化するようにします。冗長な記述も不要になりますし、1回の変化値を自分で計算する必要もなくなります。

default-macro.mmlで定義されているspectraは2種類あります。

 * SPECTRA_ONESHOT 絶対指定命令, 相対命令, 開始値, 終了値, 開始待機時間, 変化期間
 * SPECTRA_TRIANGLE 絶対指定命令, 相対加算命令, 相対減算命令, 開始値, 終了値, 開始待機時間, 変化期間

実際にMMLを書く時に、これらのマクロ命令を直接使うことは無いでしょう。これらを応用した命令が次のように定義されています。（@<table>{spectra}）

//table[spectra][spectra応用]{
固定命令	oneshot 	triangle
----------------------------------
P（パン）	P_	Pt
V（ボリューム）	V_	Vt
E（エクスプレッション）	E_	Et
t（テンポ）	t_	tt
M（モジュレーション）	M_	Mt
B（ピッチベンド）	B_	Bt
//}

前者はワンショットで線形的な変化を実現し、後者はいわゆる三角波（の一種）を実現します。最大値まで加算を続け、その後は初期値まで減算します。開始待機時間と変化期間は数値ではなく音長指定です。


== デバッグ出力

mugeneに限らず、多くのMMLコンパイラにありがちなのが、意図したものと違うものが打ち込まれたり生成されたりすることです。これをチェックする作業は、プログラミングにおけるデバッグ作業に近いものがあります。割と苦痛なので、これを緩和する手段を用意したいところです。

mugene MMLには@<tt>{DEBUG}@<i>var</i>という命令があります。これを使うと、この命令が出現した時点での変数の値がコンパイル時（mugene.exe実行時）にコンソールに出力されます。

MML打ち込み時によくあるのが、トラックごとのタイミングが合っておらず、どこかのトラックだけ音符・休符が足りない、という状況です。これを確認するためには、@<tt>{default-macro.mml}が内部的に使っている@<tt>{__timeline_position}をデバッグ出力します。そうすると、その時点までのトータルステップ数が出力されるので、これが合っていないチャンネルのMMLを調べて問題を解決すると良いでしょう。

== コメントアウト

楽曲が長くなってくると、コンパイルした結果を確認するために再生しても、確認したいところまでの待機時間が長くなってしまいます。これでは作業にならないので、mugeneではコンパイル時に途中までの部分をスキップできるディレクティブ命令を用意しています。@<tt>{#comment}で始まる行から、@<tt>{#endcomment}で終わる行まではコンパイルされません。

もちろん、コメントアウトしている間に音色設定やテンポ指定などが含まれていると、期待している内容と違うMIDIファイルが生成されてしまうので、重要なものは適宜これらの外に置いたり、部分部分で@<tt>{#endcomment}と@<tt>{#comment}を追加してやると良いでしょう（逆に、いつでもそうできるようにMMLのテキストを構成しておくようにしておくと、作業が楽になります）。



= パート別MML打ち込み技法

この章では、mugene MMLの機能を活用して、さまざまなトラックを打ち込んでいく際に有用な技法を書き連ねていきます。打ち込み技法には、ある程度はセオリーもあると思いますが、個人差がそれなりにある分野であるはずです。筆者には打ち込みトレーニング等の知見は無く、ここは完全に筆者の個人的な経験と感覚に基づいて書いているので、そういうものであると思って読んでください。

楽器にも音色にもいろいろあると思いますが、ここでは典型的なベース、ギター、ドラム、キーボードのみを対象とします。

== ベース

ベースは単音で、打ち込みを始めやすいパートです。ベースの音色はMIDI楽器では@32〜@39に割り当てられていますが、アコースティック、フィンガリングベース、フレットレスベース、スラップベース、シンセベースなど、楽器の種類と奏法がごちゃごちゃになっています。しっかりしたMIDI音源であれば、バンク・セレクトで統一的に打ち込める音が選択できるでしょう。

DAWで打ち込む時はこれらのベースの種類は別々のトラックにすることが多そうですが、mugene MMLではFINGER とか SLAP といったマクロを定義して切り替えるようにすれば、1トラックで自然に表現することもできます@<fn>{frequent_progchg}。

//footnote[frequent_progchg][MIDI楽曲で音色を短時間で頻繁に変更すると、古いデバイスでは処理落ちすることもあって、推奨されなかったものですが、現代的な問題ではなかろうという前提で書いています。無いとは思いますが、環境によっては避けたほうがよいかもしれません。]

ベースはコードのルートになる音で、作りながら動かしたいこともあるでしょう。mugene MMLには、@<tt>{K}というコマンドがあり、もし必要になったらそれ以降のノート命令のキーを全てずらすことが可能です。

ベースは、ギターほど多くはありませんが、たまにスライド奏法で音階を上げ下げすることがあります。このような場合にはピッチベンドのspectra命令@<tt>{B_}が便利です。

== ギター

ギターは生演奏の躍動感が強く、MIDI打ち込みでもかなり難易度が高いパートです。あきらめるところは割り切って、表現できる範囲でがんばっていくとよいでしょう。

ギターの音色は@24〜@31にありますが、これもアコースティックギター、ジャズギター、ミュート、オーバードライブ、ディストーション、ハーモニクスと、楽器の種類と奏法がごちゃごちゃになったものです。もうひとつ、@120はギターのフレットノイズとなっています。アコースティックな打ち込みでたまに使うと効果的でしょう。

RolandやYamahaなどのハードウェア音源には、ギターにうまく適用できるようなコンプレッサー、オーバードライブ、ディストーションといったエフェクトをシステムエクスクルーシブで設定できるものがあります。これらのベンダーではインサーションエフェクトと呼ばれています。ギターチャンネルではこれらを活用したほうがよいでしょう。

マルチギター構成にしたい（ギタリストが2人いるようなバンドのサウンドにする）場合は、チャンネルを分けて、別々のギター音色を割り当てたり、エフェクトパラメータを変えて、音が重ならないようにしたほうがよいでしょう。バッキング担当のギターはコードを定義するマクロを活用するのがよいでしょう。特に、コードをカッティングで弾く場合にはゲートタイムを短めにしますが、カッティング用のコードマクロと通常のフィンガリング用のコードマクロを別々に定義しておくと、クールな演出が簡単になります。

ゲートタイムが調整されているかいないかで、バッキングのギターの印象はまるで変わります。また、音がちゃんとカットされていないとふにゃふにゃした印象になりますし、スパッと切れすぎてもスカスカになってしまうので、ゲートタイムを使ったり、@<tt>{DSD}などでディレイ・エフェクトを適用したり（ディレイはレベル以外にも遅延タイミングなどを調整できます）、場合によってはベロシティを小さくしたノートを手動で追加して表現します。

リードギターに出現しがちなスライド奏法の使い方は、ベースと同様です。ベースと異なりギターは音域が高いので、1オクターブくらいフルにスライドしないと弱々しい印象になることがあります。筆者が@<tt>{PITCH_BEND_SENSITIVITY}と@<tt>{BEND_CENT_MODE}を常に24に設定しているのは、ほぼギターのためです。

== ドラム

ドラムチャンネルは、まず音色をきちんと選択したほうが良いでしょう。General MIDI音源ではドラムの音色を選択するということ自体が観念されていませんが、ハードウェアMIDI音源などでは通常はプログラムチェンジでドラムセットを選択できます。@0にはロック・ポップス系の無難なドラムセットがあるのが一般的です。ジャズっぽい音楽にするならブラシなども含まれているジャズのセット、ハードロックやメタルなどのジャンルにするならパワーのあるドラムセット、EDMやハウスにするならテクノ系のセットなどが選択できることでしょう。

ドラムチャンネルで出す音を全て1トラックで記述するのは合理的ではありません。リズムパートの多くは繰り返しになります。繰り返しを効率よく使うためには、ばらばらになるパートはバラバラにしておいたほうがよいでしょう。具体的には、キックドラム、スネアドラムとタム、ハイハットとシンバルくらいで分けておくとよいです。両手と片足（場合によっては両足）の分だけトラックがあると考えるとよいでしょう。クラッシュシンバルは小節の始めやフィルインに使われますが、ハイハットと独立しているとたまに手が3本あることになってしまって格好悪いので、筆者はまとめたほうが良いと思っています@<fn>{drum_partitions}。

//footnote[drum_partitions][実のところ筆者はクラッシュシンバルは別のパートに分けがちなのですが、これは単に筆者のバックグラウンドがポリフォニックなMIDIではなくFMやPCMチャンネルで打ち込んでいた経験を引きずっているためです…]

クラッシュシンバルは、しっかりした音源だと複数用意されていて、デフォルトで左と右にパンが分かれていたりしますが、そのような音源では、ドラムパートのパンは（通常は）ノートごとに自分で調整することが可能です。

ドラムトラックで表現力に差が現れるのは、グルーヴ感です。音楽のジャンルによっては、リズムが「走る」ものがあったり「モタる」ものがあったりします。少しドラムをモタらせたいな、と思ったら、r96などをトラックの先頭に置きましょう。逆に走らせたいと思ったら、r-96などを置きます（rは休符の命令ですが、前章で説明したとおり、マイナス値を指定すると時間を巻き戻すことができます）。そしてノートによってたまに早めたり遅めたりすると、機械的ではないリズム感が出てきます@<fn>{automated_groove}。

//footnote[automated_groove][本当はこういうグルーヴ感を自動生成できるspectraがあると良いのですが、今のところ実装できていません。筆者はあまりコンパイル時にランダムで変化を付けたがらない打ち込み屋なので消極的だということもあります。]

グルーヴ感を演出できるもうひとつの要素はベロシティです。全てのノートを同じベロシティで演奏すると、ドラムは機械的で味気ないものになります。位置によってベロシティを10とか20とか下げてみるとこれが緩和されます。筆者の場合、そもそも音量指定を伴うマクロを使用しています。

//emlist{
#macro 11       HA {c0,,100r}
#macro 11       HB {c0,,90r}
#macro 11       HC {c0,,100r}
#macro 11       HD {c0,,70r}
#macro 11       HE {c0,,60r}
A 11    CH10 v80 l16
C 11    [ HB HE HC HE HA HD HB HE HB HE HC HE HA HE HC o ]3
//}

v60まで下がると、v100の音に比べてだいぶ小さくなりますが、聞こえてはいます。実のところ、ハイハットを叩くときは、普通に叩いているときと、小さく触れているときがあるはずで（ゴーストノート）、後者をきちんと打ち込んでやることで、より自然なドラムに聞こえるようになります。

ちなみに、オーケストラサウンドを作っている場合はティンパニ、EDMなどであればオーケストラ・ヒットなどがよく使われますが、これらはドラムパートではなく@47や@56を使って普通のチャンネルに打ち込めます。

== キーボード

キーボードのパートは、生演奏でもMIDIシンセサイザーなどが使われているので、特段難しい事情は何もないでしょう。さまざまな音があるので、趣味にあったものを選ぶとよいでしょう。もちろん入れなくてもいいし、複数パートあっても全く問題ないでしょう。ここではいくつかの楽器を挙げて補足説明します。

(1) ピアノ - @0〜@7にあります。ピアノにはさまざまな種類があるので、好きなものを選ぶと良いと思います。ピアノで特に有用なのはホールド（ダンパーペダル）のCCで、これをオンにしたりオフにしたりすると、アルペジオ奏法を簡単に実現できます。音源によって再現の仕方が全く異なるので、さまざまなMIDI楽器で再生することを意図しているのであれば、0と64だけにする、といったやり方もありです。

少し凝った作曲を目指している人は、もしかしたら平均律ではなく純正律などを使っているかもしれませんが、MIDI楽器によっては純正律に最適化された倍音調整をNRPNやSysExのパラメーターで与えることが出来るものも存在します。筆者は一度も使ったことがありませんが、場合によっては活用できるでしょう。

(2) オルガン - @16〜@23はオルガンというカテゴリーになっています。実際にはハーモニカやアコーディオンまで含められています。オルガンはロックのコードなどで便利です。楽器によってはロータリーエンコーダーやフェイザーなどのエフェクトが用意されており、オルガンには非常に適しています。もちろんディストーションなどをかけるのもありです。

(3) ストリングアンサンブル - @48〜54はストリングスやクワイアなど、和声に適した音色が揃っており、アタックが弱いので他のパートが構築するリズム感を邪魔せずにコードを構成できます。ピアノなどで打ち込むと打鍵が強くて邪魔だ、という場合に有用でしょう。

これらの音色に限らず、どの音色でも適用できる音の強弱の時間的変化として、<b>{エンベロープ}があります。エンベロープはNRPNで実装している音源でのみ適用できるパラメーターですが、RolandのGSとYamahaのXGでは規定されており、mugene MMLでも@<tt>{nrpn-gs-xg.mml}で@<tt>{ENV_ATTACK}、@<tt>{ENV_DECAY},
@<tt>{ENV_RELEASE}として定義されています。アタック、ディケイ、リリースといった変化ポイントがあり、発声時の強さを控えめにしたり、音の減衰をゆるやかにしたりといった調整が可能です。




= プログラムとしてのmugene

本書の最後は、プロジェクトの位置付けやコンパイラの実装としてのmugeneについて、開発者視点で何点か書いておこうと思います。

== コンパイラの構成

=== パーサージェネレーター

mugeneではjayというLALRのパーサージェネレーターを使用しています。これはもともとJava用に2000年頃に作られていたjayを、MonoプロジェクトでC#のパーサーを実装するためにC#のコードを生成できるように移植されたものです。筆者が慣れていたので使用したのですが、現在ではmonoのリポジトリのソースに含まれている程度なので、書き直すべきもののひとつです。2018年現在であればEto.Parseあたりが良いかと筆者は考えていますが、使ってみれば評価が変わるかもしれません。MMLは構文がシンプルで、特にmugeneは命令語がほぼカスタマイズ可能なので、もともとあまりパーサージェネレーターには馴染まないのですが、特に不便でもないので使っています。

=== セマンティックモデル

ここは実のところ筆者があまり良いモデルではなかったと考えているところですが、mugene MMLのセマンティックモデルには、あまり有用な部分が多くありません。というのは、多くの命令がプリミティブ命令に基づいて@<tt>{default-macro.mml}上で実装してしまっているために、ノートオンやノートオフを抽象的にノートとして扱う程度のセマンティクスですら、簡単に扱えなくなってしまっているためです。

これがどのように問題かというと、MMLデータ列に対する、より高度な計算処理（状態によって自動的にRPN/NRPNを変更したりポルタメントを加工したりすること）が難しくなっているのです。

この問題を解決するには、@<tt>{default-macro.mml}などにおけるマクロ定義に、セマンティック情報を付加するアノテーションを設定できたりすれば良いのかもしれませんが、そもそもMIDIメッセージに相当するプリミティブ命令までフラットに展開するモデルを作り変えたほうが良いのかもしれません@<fn>{nextgen}。

//footnote[nextgen][それはもはやmugeneとは別のコンパイラ・プロジェクトであるというべきでしょう。]

もっとも、マクロ定義などをよりプログラミング言語の関数に近づけて、「定義の中に引数も含まなければならない」ような状態になると、実用に耐えないマクロ定義構文になってしまうことも考えられます（コード定義マクロがノート命令と同じだけの複雑な引数リストを適用しなければならなくなると大変です）。この辺りのMML固有の事情は、実装時に注意しておいたほうがよいでしょう。

=== アクセス修飾子

プログラミング言語の多くは、シンボル（変数や関数）をpublicに指定したりprivateに指定したりできますが（privateなものは一般のユーザーが利用できない存在となります）、mugene MMLの命令にそのような区別はありません。@<tt>{default-macro.mml}では、さまざまなマクロがMML命令のコーディングを省力化するために定義されていますが、何がそのための命令なのかを外から判断することはできません。一般ユーザー向けの命令は、マニュアルに記載しています。

== デバッガビリティとテスタビリティ

mugeneの開発時に意識していたのが、MMLの打ち込み間違いをなるべく早目に検出できるようにしたいというものでした。これは最終的にシンプルなprint文に相当するDEBUG命令で済ませることになりました。

もうひとつ課題になっているのが、マクロは何段階にもネストして展開されることになるため、マクロ展開のどこかに問題があるときに、それをエラーレポートで把握しづらいということです。これは現在のような処理モデルで、どのように解決するのが良いのかわかっていません。マクロ展開のスタックトレースのようなものは出したほうが良いのかもしれません。

== オープンソース

mugeneはgithub上で公開されているOSSです。2018年にこんなことを特徴として挙げるのはもはや冗談のように聞こえますが、MMLコンパイラが主要な音楽制作ツールであった20世紀には、特に国産ツールが（「フリーソフト」とは全く意味の異なる）自由ソフトウェアやオープンソース@<fn>{oss-word-history}として開発されていることはほぼありませんでした。mugeneは2010年頃から存在しているコンパイラであり、OSSであることはごく当たり前の選択肢でした。

//footnote[oss-word-history][オープンソースという言葉が提案されたのは1998年であり、これ以前に隆盛したMMLのツールにOSD compliantであることを意識したものが無かったのは当然のことです。]

= あとがき

本書では、実際にMMLの打ち込みを始められるようになるまで、mugeneの機能をほぼ全面的に説明してきたつもりですが、いかがだったでしょうか。mugene自体まだツールチェインとして未整備なところが多いですが、なるべく汎用的に使えるように作っているつもりなので、使ってみて便利だったところや改善してほしい点などがありましたら、筆者までご連絡いただければと思います。

本書は技術書典4の1週間前に思い立って、ほぼ3日間で書き上げたもので、本当はもっと短めの雑なコピー本になるはずだったのですが、気がついたらこんな長さになってしまいました。古来MMLのマニュアルやガイドというものはそれなりの長さを伴っていたはずなので、最初からわかっているべきだったのかもしれませんが、すっかり失念しており、ひさびさにこういう文章を書いてみて思い出しました。

今後も音楽ツールを題材に（次は本当にライトな）本をまとめていければと思います。


