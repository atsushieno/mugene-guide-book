
= プログラムとしてのmugene

本書の最後は、プロジェクトの位置付けやコンパイラの実装としてのmugeneについて、開発者視点で何点か書いておこうと思います。

== コンパイラの構成

=== パーサージェネレーター

mugeneではjayというLALRのパーサージェネレーターを使用しています。これはもともとJava用に2000年頃に作られていたjayを、MonoプロジェクトでC#のパーサーを実装するためにC#のコードを生成できるように移植されたものです。筆者が慣れていたので使用したのですが、現在ではmonoのリポジトリのソースに含まれている程度なので、書き直すべきもののひとつです。2018年現在であればEto.Parseあたりが良いかと筆者は考えていますが、使ってみれば評価が変わるかもしれません。MMLは構文がシンプルで、特にmugeneは命令語がほぼカスタマイズ可能なので、もともとあまりパーサージェネレーターには馴染まないのですが、特に不便でもないので使っています。

=== セマンティックモデル

ここは実のところ筆者があまり良いモデルではなかったと考えているところですが、mugene MMLのセマンティックモデルには、あまり有用な部分が多くありません。というのは、多くの命令がプリミティブ命令に基づいて@<tt>{default-macro.mml}上で実装してしまっているために、ノートオンやノートオフを抽象的にノートとして扱う程度のセマンティクスですら、簡単に扱えなくなってしまっているためです。

これがどのように問題かというと、MMLデータ列に対する、より高度な計算処理（状態によって自動的にRPN/NRPNを変更したりポルタメントを加工したりすること）が難しくなっているのです。

この問題を解決するには、@<tt>{default-macro.mml}などにおけるマクロ定義に、セマンティック情報を付加するアノテーションを設定できたりすれば良いのかもしれませんが、そもそもMIDIメッセージに相当するプリミティブ命令までフラットに展開するモデルを作り変えたほうが良いのかもしれません@<fn>{nextgen}。

//footnote[nextgen][それはもはやmugeneとは別のコンパイラ・プロジェクトであるというべきでしょう。]

もっとも、マクロ定義などをよりプログラミング言語の関数に近づけて、「定義の中に引数も含まなければならない」ような状態になると、実用に耐えないマクロ定義構文になってしまうことも考えられます（コード定義マクロがノート命令と同じだけの複雑な引数リストを適用しなければならなくなると大変です）。この辺りのMML固有の事情は、実装時に注意しておいたほうがよいでしょう。

=== アクセス修飾子

プログラミング言語の多くは、シンボル（変数や関数）をpublicに指定したりprivateに指定したりできますが（privateなものは一般のユーザーが利用できない存在となります）、mugene MMLの命令にそのような区別はありません。@<tt>{default-macro.mml}では、さまざまなマクロがMML命令のコーディングを省力化するために定義されていますが、何がそのための命令なのかを外から判断することはできません。一般ユーザー向けの命令は、マニュアルに記載しています。

== デバッガビリティとテスタビリティ

mugeneの開発時に意識していたのが、MMLの打ち込み間違いをなるべく早目に検出できるようにしたいというものでした。これは最終的にシンプルなprint文に相当するDEBUG命令で済ませることになりました。

もうひとつ課題になっているのが、マクロは何段階にもネストして展開されることになるため、マクロ展開のどこかに問題があるときに、それをエラーレポートで把握しづらいということです。これは現在のような処理モデルで、どのように解決するのが良いのかわかっていません。マクロ展開のスタックトレースのようなものは出したほうが良いのかもしれません。

== オープンソース

mugeneはgithub上で公開されているOSSです。2018年にこんなことを特徴として挙げるのはもはや冗談のように聞こえますが、MMLコンパイラが主要な音楽制作ツールであった20世紀には、特に国産ツールが（「フリーソフト」とは全く意味の異なる）自由ソフトウェアやオープンソース@<fn>{oss-word-history}として開発されていることはほぼありませんでした。mugeneは2010年頃から存在しているコンパイラであり、OSSであることはごく当たり前の選択肢でした。

//footnote[oss-word-history][オープンソースという言葉が提案されたのは1998年であり、これ以前に隆盛したMMLのツールにOSD compliantであることを意識したものが無かったのは当然のことです。]


