

= mugene MML文法解説

この章では、チュートリアルまでではカバーできなかった、MML文法のもう少し細かい部分について説明していきます。この章の内容を知らなくてもチュートリアルの範囲でMMLを書くことはできますが、知っておくと有用な情報やMML文法の論理的な側面などはこの章にあります。


== デフォルトマクロ: オーバーライド可能なMML命令定義

MMLはコンパイラの数だけ文法が存在するものです。mugeneのMML文法も独自のものです。mugeneはそれなりにしっかりした楽曲を制作できる程度には高度なもので、たとえばマクロ命令を定義して使用することが出来ます。

mugene MMLのひとつの大きな特徴は、自身の命令の大半をmugeneのマクロ定義構文によって定義していることです。コンパイラのコード自身もgithub上で公開しているので@<fn>{repo}、コードを独自にカスタマイズして使うことも可能ですが、そこまでやらなくても各種MMLコマンドを定義している@<tt>{default-macro.mml}というファイルをカスタマイズすることも可能です。

//footnote[repo][https://github.com/atsushieno/mugene]

その気になれば、かなり柔軟に命令を定義することも可能ですし、たとえばこれをカスタマイズして、実質的に大文字・小文字を区別しない命令セットを定義することも出来るでしょう。ただし、これは非常に難易度が高く、また簡単に他のマクロ定義とコンフリクトを起こすことにもなりうるので、基本的にはデフォルト定義のマクロの内容は書き換えない前提で説明を進めます。読者によっては、オクターブ相対指定や音量相対指定といった命令の「向き」が逆になっていることが耐え難い苦痛だという人もいるかもしれません。そういう人はこれらの命令を上書きすればよいのです。@<fn>{override_options}

//footnote[override_options][コンパイラによっては、これらの命令の向きをオプションで逆にしてくれるものなどがあったりしますが、他にも@<tt>{q}が@<tt>{Q}でないと受け付けない人、@<tt>{T}が@<tt>{t}でないと我慢できない人など、いろいろな人がいると思うので、mugeneでは命令定義そのものをカスタマイズ可能にする途を選びました。]

デフォルトマクロを書き換えて独自のデフォルトマクロを使いたい場合は、mugene.exeの引数にそのファイル名と@<tt>{--nodefault}という引数を追加します。そうすると、標準で取り込まれるデフォルトマクロは取り込まれなくなります。


== トラック行とディレクティブ行とコメント行

mugene MMLファイルは、行単位で解析されます。mugene MMLには、3種類の行があります。

 * @<b>{トラック行}: 音楽の演奏データを実際にトラックごとに記述していきます。行頭はオプションとなるブロック識別子アルファベットの後、トラック番号を表す数値になります。
 * @<b>{ディレクティブ行}: マクロ定義やメタデータ定義など、各種の非演奏データを記述していきます（これには、対象トラックが限定されるものと、そうでないものがあります）。行頭は@<tt>{#}になります。
 * コメント行: @<tt>{//}で始まる行で、以降改行まで無視されます。

mugene MMLにこれら以外の行は存在しません。@<tt>{#}、@<tt>{//}以外の文字で始まる行はトラック行となり、行頭をブロック識別子とトラック指定として解釈できない行はエラーとなります。ただし、空白文字で始まった場合、その行は前の行のトラック番号を引き継ぐトラック行となります。

マクロ定義が長くなったりして、次の行にも内容を続けたい場合には、行末にバックスラッシュを付加します。（@<img>{mml_wrap_backslash}）

//image[mml_wrap_backslash][バックスラッシュで次の行に繋げる例]


== 複数トラックの一括指定

トラック番号は数値ですが、実はここには単一の数値ではなく、複数のトラックをまとめて指定することが可能です。@<tt>{,}でその両脇の指定内容を結合し、<tt>{-}で範囲指定となります。例を挙げます。

 * @<tt>{1,2} : トラック1と2が対象です
 * @<tt>{3-5} : トラック3、4、5が対象です
 * @<tt>{1,3-5,7} : トラック1、3、4、5、7が対象です。

FM音源の世界では、同じパターン、同じ音色でも、周波数やタイミングを少しずらすことで厚みのある音を作り出すという表現技法がありましたが、MIDIにおいて同じ内容のデータを演奏する意味はほぼありません（厚みを出したかったらリバーブやディレイを適用すれば足ります）。しかし、作曲のパターンとして、キーを5度ずらして同じフレーズを演奏したり、あるいはユニゾンで別の楽器を演奏したりといったかたちで、同じMMLを複数トラックで演奏することはありえます。複数トラック指定はこういった場合に便利です。

== 引数付きマクロ

前章ではマクロ定義のごく基本的な部分を紹介しましたが、ここではマクロ定義の複雑な部分も含めて解説します。マクロ定義はディレクティブ行で、書式は次のとおりです。

//emlist{
#macro トラック番号 識別子 引数リスト { 内容 }
//}

トラック番号は通常は不要で、特定のトラックでのみ適用されるマクロを定義する場合には、前述のトラック指定の方法で指定します（範囲指定などが可能です）。

引数リストは引数定義を@<tt>{,}（カンマ）区切りで繋げたもので、引数定義は次のようになります。

//emlist{
識別子 : 型名 = デフォルト値
//}

デフォルト値が無い場合は、@<tt>{=}以下を省略します。

マクロ定義の内容は、トラック行のMMLと同様です。引数の内容を参照するには @<tt>{$} を識別子の前に付けます。次の例では、DTE命令を定義しています（実際に@<tt>{default-macro.mml}で使用されているものです）。

//emlist{
#macro DTEM val:number { CC #06,$val }
#macro DTEL val:number { CC #26,$val }
#macro DTE msb:number,lsb:number { DTEM$msb DTEL$lsb }
//}

=== 識別子

識別子は、マクロ名や引数の定義で用いられる文字列で、主としてMML中で命令を識別するためにある概念です。

一般的なプログラミング言語とは異なり、mugene MMLでは多くの文字が識別子名として許容されており（これは、MMLに慣れている人は自分の経験に合った文字を自分の好みの命令に割り当てられるようにするという意図で設計されているためです@<fn>{at_char}）、一方で（前述のとおり）一般的なプログラミング言語より厳しい制約もかかえています。

//footnote[at_char][たとえば@<tt>{@}が識別子として利用でき、実際プログラム・チェンジ命令で使われていることを思い出してください。]

識別子名の文法的制約は以下の通りです:

 * 常に禁止される文字: 0 1 2 3 4 5 6 7 8 9 " , { }
 * 先頭で使用できない文字: - + ^ ? #
 * 先頭でしか使用できない文字: / : ( )

=== 型: 数値、音長、文字列

MML命令のほとんどは、引数（パラメータ）を伴います。どんなパラメータを与えるかによって、（SMFに）出力される発音（命令）が変わってきます。

たとえば、今のトラックのオクターブを指定する命令 o は、オクターブの高さを引数にとります（o0 ～ o10）。プログラムチェンジやコントロール(CC)、アフタータッチなどは、MIDIメッセージと同等の引数をとります。複数の引数は、','（カンマ）で区切ります。

数値は通常は10進数として解釈されますが、# を付けることで16進数として解釈されます。

発音命令と休符命令の引数は少し特殊です。これは「数値」とは別に扱われる「音長」となります。たとえば r は休符命令ですが、r4 と書いた場合は4分休符になります。r1 と書いた場合は全休符になります。r8. と書いた場合は付点8分休符になります。

しかし、r4はコンパイラの内部では、4という数値としては処理されません。音長は、内部的には「ステップ数」という数値に変換されます。標準状態では、r4 は48ステップという数値になり、r1 は192ステップという数値になり、r8. は36ステップという数値になります。全休符を192として、音の長さを乗除算して出した数値になります。

音長は、数値の前に % を付けることで、このような数値として直接記述することもできます。たとえば r%48 は4分休符と同じです。

ちなみに、全休符に対応する 192 という数値は、@<tt>{#basecount}というディレクティブ命令で変更できます。

MML命令の中には、他にも「文字列」を引数に取るものがあります。文字列の値は "..." のかたちで、ダブルクォーテーションで囲んで記述します。一部の文字は、文字列の中で直接表現することができないので、「エスケープシーケンス」を使って表現します:

 *   \r : 改行(CR)
 *  \n : 復改(LF)
 *   / : スラッシュ
 *   " : ダブルクォーテーション
 *   \ : 円記号/バックスラッシュ

最後に、「型」について説明します。型はマクロを定義したり、MMLリファレンスを読んだりする時のために、理解しておく必要があります。

どのMML命令の引数にも「型」があります。命令を使うときは、それぞれの引数の型で期待される値を指定しなければなりません。mugene MMLには、以下の4種類の引数型があります:

 * number : 数値。整数となります。
 * length : 音長。上記の通りの意味で解釈されます。内部的には数値となります。末尾に付点を付けることで長さが1.5倍になり（多重付点も指定可能で、1.75倍、1.875倍…となります）、%を付けることでステップ数の直接指定となります。
 * string : 文字列となります。
 * buffer : これは __STORE という特殊な命令のために用意された、特殊な型で、通常はmugeneユーザーが使う必要はありません。

=== 変数

mugene MMLは音楽を打ち込むためのマクロ言語であって、一般的なプログラミング言語とは性格が大きく異なります。通常、ユーザーがプログラミングにおける「変数」のようなものを意識する必要はありません。しかし、いくつかの命令がどのように実装されているか気になる読者もいると思うので、説明します。変数はオクターブ指定、デフォルト音長指定、ベロシティ指定などでふんだんに使われています。

各トラックでは、変数を使用（格納したり参照したり）できます。使用するためには、事前に@<tt>{#variable}というディレクティブ行で定義したものになります。定義内容はマクロ引数と同様です。

//emlist{
#variable 識別子 : 型名 = デフォルト値
//}

変数の参照は、マクロ引数と同じ @<tt>{$変数名} となります。マクロ定義の中で活用できます。変数の代入は特殊で、@<tt>{__LET}という「プリミティブ命令」を使います@<fn>{primitives}。

//footnote[primitives][mugene MMLでは、ほぼすべてのMML命令を自分で定義できますが（それを実際に行っているのが@<tt>{default-macro.mml}です）、それらは最終的に「プリミティブ命令」の呼び出しになります。他にはMIDIのバイトデータになる@<tt>{__MIDI}や、マクロの呼び出しを動的に行う@<tt>{__APPLY}などがありますが、ここでは説明しません。]


== ノート命令の詳細とゲートタイム

音楽演奏データの打ち込みにあたって、意識しておくべきものに、音符の長さと実際に発音する音の長さの違いがあります。音楽記号にスタッカートというものがありますが、これは発音を短くすることを演奏者に指示するものです。スタッカート用のストリングス音色のように、バンク・セレクトで選択できる音源があれば、それで十分かもしれませんが、そうでなくても、発音する時間と次の発音まで待つ時間は別のものとして扱いたい音色やフレーズが、楽曲を制作しているとしばしば現れます。

このような時には@<b>{ゲートタイム}を活用します。ゲートタイムとは、音符に対する、実際の発音時間のことで、音長に対して割合指定したり、ステップ数を絶対値で短縮したりするものです。

mugene MMLでは、@<tt>{Q}@<i>{n}で割合指定（分母を@<tt>{GATE_DENOM}@<i>{n}で指定する分数指定です）、@<tt>{q}@<i>{n}でステップ数指定する、2つのゲートタイム指定方法を用意しています。これらはノート命令をMIDIメッセージのノートオンとノートオフに展開する際に適用されます。たとえば、@<tt>{q2}と指定されていたら、@<tt>{c4}は「ドを発音し、46カウント待ち、ドを消音し、2カウント待つ（そして次へ）」となります。

より突っ込んだ話を書くと、mugene MMLでは、ノート命令や休符命令を使うたびに、現在の演奏位置をあらわす@<tt>{__timeline_position}という変数の値を加算していきます。r命令には実はマイナスの値も指定でき、@<tt>{r-1}と書くと、全休符分巻き戻すことができます。和音を定義する時に音長が0のノート命令を記述しましたが、進むステップ数が0だということがこれで理解できると思います@<fn>{zero-length}。

//footnote[zero-length][音長0のノートの実際の発音長を調整するために、mugeneではさらに特別な命令@<tt>{__ON_MIDI_NOTE_OFF}を必要としましたが、これはさらなる実装の詳細なので、ここでは言及しません。]

== ピッチベンドとbend cent mode

MIDIメッセージE0Hはピッチベンドで使用されます。この値は14ビットの整数で、最大値は8191、最小値は-8192となります。この最大値と最小値が元の音からどれくらい離れているかは、ピッチベンド・センシティビティというRPNで表現されます。@<tt>{default-macro.mml}では@<tt>{PITCH_BEND_SENSITIVITY}というショートカット命令があります。この値が最大24で1オクターブです。

また、ユーザーが実際に-8192〜8191の範囲で数値を指定するのは困難なので、mugeneではB命令に即値モードとパーセンテージ指定モードの2つを用意しています。@<tt>{BEND_CENT_MODE}@<i>{n}命令を使うと、8192をこの値で割った数値に100をかけた値が、MIDIメッセージE0Hの引数として適用されます。この値とピッチベンド・センシティビティが同一であれば、100で半音階1つに相当します。これなら分かりやすいでしょう。@<fn>{muc-pitchbend}

//footnote[muc-pitchbend][この機能は筆者が過去によく使っていたMUC MML compilerというツールの機能を実現したものです。MUCには他にも筆者が影響を受けた機能がいくつかあります。]

=== spectra

MIDIで打ち込んでいると、ピッチベンドで音程を少しずつ上げ下げしたり、音量を少しずつ下げていったり、音像を右から左に少しずつ動かしたり、テンポをゆっくり落としたりしたくなることがあります。mugene MMLには、これを実現する機能@<b>{spectra}があります。

spectraは（スペクトラムから採っているのですが）、連続的に変化する数値を引数にとる連続的な命令を生成するためのものです。手作業で @<tt>{B0 r48 B-8 r48 B-8 r48 B-8 r48 ...} のように指定する代わりに、@<tt>{B_0, -200, 0, 2} のように「開始値、終了値、開始待機時間、変化期間」を指定するだけで滑らかに値が変化するようにします。冗長な記述も不要になりますし、1回の変化値を自分で計算する必要もなくなります。

default-macro.mmlで定義されているspectraは2種類あります。

 * SPECTRA_ONESHOT 絶対指定命令, 相対命令, 開始値, 終了値, 開始待機時間, 変化期間
 * SPECTRA_TRIANGLE 絶対指定命令, 相対加算命令, 相対減算命令, 開始値, 終了値, 開始待機時間, 変化期間

実際にMMLを書く時に、これらのマクロ命令を直接使うことは無いでしょう。これらを応用した命令が次のように定義されています。（@<table>{spectra}）

//table[spectra][spectra応用]{
固定命令	oneshot 	triangle
----------------------------------
P（パン）	P_	Pt
V（ボリューム）	V_	Vt
E（エクスプレッション）	E_	Et
t（テンポ）	t_	tt
M（モジュレーション）	M_	Mt
B（ピッチベンド）	B_	Bt
//}

前者はワンショットで線形的な変化を実現し、後者はいわゆる三角波（の一種）を実現します。最大値まで加算を続け、その後は初期値まで減算します。開始待機時間と変化期間は数値ではなく音長指定です。


== デバッグ出力

mugeneに限らず、多くのMMLコンパイラにありがちなのが、意図したものと違うものが打ち込まれたり生成されたりすることです。これをチェックする作業は、プログラミングにおけるデバッグ作業に近いものがあります。割と苦痛なので、これを緩和する手段を用意したいところです。

mugene MMLには@<tt>{DEBUG}@<i>{var}という命令があります。これを使うと、この命令が出現した時点での変数の値がコンパイル時（mugene.exe実行時）にコンソールに出力されます。

MML打ち込み時によくあるのが、トラックごとのタイミングが合っておらず、どこかのトラックだけ音符・休符が足りない、という状況です。これを確認するためには、@<tt>{default-macro.mml}が内部的に使っている@<tt>{__timeline_position}をデバッグ出力します。そうすると、その時点までのトータルステップ数が出力されるので、これが合っていないチャンネルのMMLを調べて問題を解決すると良いでしょう。

== コメントアウト

楽曲が長くなってくると、コンパイルした結果を確認するために再生しても、確認したいところまでの待機時間が長くなってしまいます。これでは作業にならないので、mugeneではコンパイル時に途中までの部分をスキップできるディレクティブ命令を用意しています。@<tt>{#comment}で始まる行から、@<tt>{#endcomment}で終わる行まではコンパイルされません。

もちろん、コメントアウトしている間に音色設定やテンポ指定などが含まれていると、期待している内容と違うMIDIファイルが生成されてしまうので、重要なものは適宜これらの外に置いたり、部分部分で@<tt>{#endcomment}と@<tt>{#comment}を追加してやると良いでしょう（逆に、いつでもそうできるようにMMLのテキストを構成しておくようにしておくと、作業が楽になります）。




